# Design Document for Project 2: User Programs

## Group Members

- ლაშა ბუხნიკაშვილი <lbukh16@freeuni.edu.ge>
- ზაურ მეშველიანი <zmesh15@freeuni.edu.ge>
- ბაკურ ცუცხაშვილი <btsut16@freeuni.edu.ge>
- ლუკა ჭუმბურიძე <lchum16@freeuni.edu.ge>

# Argument Passing

დავალების პირველ ნაწილში საჭირო იყო `load_args` ფუნქციაში ახლად დასტარტული ფუნქციისთვის არგუმენტების გადაცემის დაწერა.

ამისთვის შევქმენით `args_data_t` სტრუქტურა

```c
struct args_data_t {
  size_t argc;
  char **argv;
  bool status; //განვიხილავთ ამ დავალების შემდეგ ნაწილში
  struct semaphore load_status_sem; //განვიხილავთ ამ დავალების შემდეგ ნაწილში
};
```

მშობელი [_ტასკი_](https://gamepedia.cursecdn.com/dota2_gamepedia/2/2a/Tusk_move_26.mp3) შვილი პროცესის სამისამართო სივრცეში აკოპირებს არგუმენტებს და აძლევს მას `strtok_r` ფუნქციით დაყოფილ არგუმენტებს.

გასათვალისწინებელია ისიც, რომ რამდენიმე ჰარს ჩვენი იმპლემენტაცია ერთ ჰარად აღიქვამს.

# SYSCALLS

## Pointer validation

სანამ უშუალოდ syscall-ების დავალებებს განვიხილავთ ავღნიშნოთ, რომ ყველა syscall-ის შესრულებისას საჭიროა, რომ კერნელი იყოს დაცული და არ დაიქრაშოს, უნდა შვეამოწმოთ გადაცემული მისამართების ვალიდურობა, რომელსაც ვახერხებთ `valid_ptr` ფუნქციის გამოყენებით, რომელსაც გადაეცემა მისამართი და მაქსიმალური დაშორება (`size`), ფუნქცია ამ მისამართIდან `size`-ით დაშორებული მისამართის ვალიდურობას ამოწმებს. ასევე გადავტვირთეთ exception handler, რომელიც არასწორი ადრესის დერეფერენსისას ვარდებოდა.

ასევე საჭირო იყო ერთი ლოქის შემოღება (`filesys_lock`), რომელსაც ყველა ფაილურ სისტემასთან მომუშავე syscall-იღებს.

# Process Control Syscalls

მეორე ნაწილში დასაწერი იყო პროცესების დასტარტვა-დალოდება და სისტემის გამორთვა. გამორთვა ტრივიალური იყო, რასაც ვერ ვიტყვით `exec`-სა და `wait`-ზე. ამ syscall-ების დაწერისთვის საჭირო იყო პროცესებისთვის სინქრონიზაციის მოფიქრება.

პროცესების სინქრონიზაციისთვის ორი ვარიანტი გვქონდა:

- შეგვენახა სასინქრონიზაციო მექანიზმები შვილეულ პროცესში
- შეგვენახა სასინქრონიზაციო მექანიზმები მშობელ პროცესში

ვარჩიეთ მეორე ვარიანტი, რადგან ვიცით, რომ მშობელი პროცესი შვილ პროცესზე ადრე არ მოკვდება, თვითონ სასინქრონიზაციო სტრუქტურა ასეთია:

```c
struct child_info_t {
  tid_t tid; // შვილის tid
  int status; // შვილის exit status, პროცესის ნაკადის შექმნისას -1-ია, ისეტება შვილის სიკვდილისას
  struct semaphore sema; // სემაფორა, რომელიც გამოიყენება შვილეულ პროცესზე wait-ით დალოდებისას, თავდაპირველი მნიშვნელობა 0-ია
  struct list_elem elem; // `children` სიაში შესანახად, იხ. ქვემოთ
};
```

შევქმენით ატომური `syn_list_t` სტრუქტურა.
ნაკადის სტრუქტურას დავამატეთ `parent_thread` ველი, მშობლის შესანახად.
ასევე დავამატეთ `children` (`struct syn_list_t`) სია `child_info_t`-ების შესანახად.

`exec` ქოლის შესრულებისას საჭიროა გავიგოთ წარმატებით ჩაიტვირთა თუ არა შვილი პროცესი ფაილიდან, რომელიც უკვე სხვა ნაკადშია, ამისთვის `process_execute` გადავაკეთეთ ისე, რომ მშობელი ელოდება შვილს ჩატვირთვის მცდელობის დასრულებამდე, შვილი კი მას ჩატვირთვის სტატუსს ეუბნება. ამას ემსახურება `args_data_t`-ის `status` და `load_status_sem` ველები.
წარმატებულად ჩატვირთვის შემთხვევაში შვილი პროცესი მშობლის ნაკადის სტრუქტურაში (`parent thread`) `children` სიაში სვამს საკუთარ `pid`-ს და 0-იან სემაფორას.

`wait`-ის გამოძახებისას პროცესი თავის ნაკადის სტრუქტურაში `children` სიაში ეძებს გადმოცემული `pid`-ის მქონე `child_info_t` წევრს და `sema` სემაფორაზე ელოდება. თავის მხრივ შვილი პროცესი დასრულებისას იგებს თავის მშობელს (თავის ნაკადის სტრუქტურაში `parent_thread`) და მის `children` სიაში ეძებს შესაბამის `child_info_t` ელემენტს საკუთარი `pid`-ით, სვამს საკუთარ exit სტატუსს და უმატებს `sema` სემაფორას.

# File Operation Syscalls

გლობალურ ლოქზე უკვე ვისაუბრეთ. ფაილური სისტემის syscall-ების შესრულებისას ვიყენებთ `file.c` და `filesys.c`-ში უკვე დაწერილ ფაილის შექმნა/გახსნა/დახურვა/წაშლის ფუნქციებს, საჭირო არის ამ ფუნქციების გამოყენებისას ნაკადის სტრუქტურაში თითოეული პროცესის fd-ების შესანახად საჭირო სინქრონიზაციის მექანიზმების და სტრუქტურების შექმნა.

fd-ების შესანახად ვიყენებთ შემდეგ სტრუქტურას

```c
struct file_info_t {
  int fd;
  struct list_elem elem;
  struct file *file_data;
};
```

და შესაბამის `thread` სტრუქტურაში შესაბამის ატომურ სიას

```c
struct syn_list_t files;
```

როგორც პირობაში ეწერა, პროგრამის executable-ის ცვლილება პროგრამის მუშაობის განმავლობაში ვერავინ უნდა შეძლოს, შესაბამისად პროცესის დასტარტვისას შესაბამისი პროგრამის ფაილს აღარ ვხურავთ და `file_deny_write`-ს ვუკეთებთ, სამაგიეროდ ფაილის სტრუქტურასვ ინახავთ რომ პროცესის დასრულებისას დავხუროთ.
რადგან პროცესს ერთი ფაილის გახსნა ბევრჯერ შეუძლია (შესაბამისად ერთსა და იმავე ფაილზე ბევრი fd უბრუნდება), ფაილის დახურვა ისე დაიწერა, რომ შესაძლებელია ფაილზე რამდენიმე fd-ს არსებობიას რამდენიმე ისე დავხუროთ, რომ სხვებს პრობლემა არ შეექმნათ.

# Additional Questions

### 1. Invalid Stack Pointer

აღწერილი შეცდომა დაშვებულია `sc-bad-sp` ტესტში, syscall interrupt-ის (0x30) გამოძახებისას, სტეკის პოინტერი არის 8 MB-ზე, რაც ვიცით რომ ამ სისტემაში არ შეიძლება. ჩვენი იმპლემენტაცია ამ ტესტში syscall_handler-ში ფოინთერის ვალიდაციას ეცდება და -1 სტატუსით დაასრულებს მუშაობას (`valid_ptr`-ის მუშაობა აღწერილია ზემოთ)

```c
  if (!valid_ptr(args, sizeof(void *))) {
    _exit(-1);
  }
```

### 2. Syscall Bad Boundary

აღწერილი შეცდომა დაშვებულია `write-boundary` ტესტში. ტესტი იძახებს write syscall-ს და გადაცემული buffer-დან size რაოდენობის ბიტის წაკითხვისას ვცდებით ვირტუალურ page-ს. ჩვენს იმპლემენტაციაში ეს გათვალისწინებული გვაქვს.
მოცემული ტესტი `syscall_write`-ში შესვლისას შემდეგი ბლოკიდან -1 სტატუსით დაამთავრებს მუშაობას.

```c
 if (!valid_ptr(buff, sz)) {
    _exit(-1);
    NOT_REACHED();
  }
```

### 3. ახალი ტესტი

მოცემულ ტესტებში არ იყო ისეთი, რომელიც შეამოწმებდა wait-ის მემკვიდრეობითობას. როგორც პროექტის პირობაში იყო აღნიშნული, პროცესებს შორის მშობელ-შვილის დამოკიდებულება არ არის მემკვიდრეობითი, ანუ თუ B A-ს შვილია, ხოლო C B-სი. A-პროცესიდან `wait (C.pid)`-ის გამოძახებიასს -1 უნდა დაბრუნდეს.

ასევე მოცემული ტესტები არ ტესტავენ შემთხვევას, როცა პროცესი დამთავრების შემდეგ საკუთარ ექსექიუთებელ ფაილს არ ხურავს. ამ შემთხვევაში `inode_open_cnt` მუდმივად იზრდება და თუ `inode_deny_write`-ს გამოვიძახებთ ფაილზე, რომელიც სინამდვილეში გახსნილი არ გვაქვს, შეცდომა აღარ ამოვარდება. არადა უნდა ამოვარდეს რადგან გაუხსნელ ფაილზე დენაი ვრაითს ვაკეთებთ.
